use anchor_lang::prelude::*;
use anchor_lang::solana_program::program::invoke_signed;
use anchor_lang::solana_program::system_instruction;

// Declare the contract's ID
declare_id!("B3G5V8XLTyXVpM8txNJgdezuCJZrVq4y4zD1aVzezEvw");

#[program]
pub mod solana_escrow {
    use super::*;

    // Initialize the escrow account with a specified amount
    pub fn initialize_escrow(ctx: Context<InitializeEscrow>, amount: u64) -> Result<()> {

        let client = &ctx.accounts.client;
        let escrow = &mut ctx.accounts.escrow;
        
        // Checks
        require!(
            client.to_account_info().lamports() >= amount,
            EscrowError::InsufficientBalance
        );

        require!(amount > 0, EscrowError::InvalidAmount);

        escrow.client = ctx.accounts.client.key();
        escrow.service_provider = Pubkey::default();
        escrow.amount = amount;
        escrow.client_approved = false;
        escrow.is_completed = false;

                // Store lamports in the PDA
                let ix = system_instruction::transfer(
                    &client.key(),
                    &escrow.key(),
                    amount
                );
        
                invoke_signed(
                    &ix,
                    &[
                        client.to_account_info(),
                        escrow.to_account_info(),
                    ],
                    &[&[b"escrow", &ctx.accounts.client.key().to_bytes(), &[escrow.bump]]],
                )?;

        // Emit the initialization event
        emit!(EscrowInitialized {
            escrow: ctx.accounts.escrow.key(),
            client: ctx.accounts.client.key(),
            amount,
        });

        Ok(())
    }

    // // Accept a service provider for the escrow
    // pub fn accept_service(ctx: Context<AcceptService>) -> Result<()> {
    //     let escrow = &mut ctx.accounts.escrow;
    //     let service_provider = &ctx.accounts.service_provider;

    //     // Ensure the escrow doesn't already have a service provider
    //     require!(
    //         escrow.service_provider == Pubkey::default(),
    //         EscrowError::ServiceAlreadyAccepted
    //     );

    //     // Set the service provider
    //     escrow.service_provider = service_provider.key();

    //     Ok(())
    // }

    // // Approve the completion of the escrow by either client or service provider
    // pub fn approve_completion(ctx: Context<ApproveCompletion>) -> Result<()> {
    //     let escrow: &mut Account<'_, EscrowAccount> = &mut ctx.accounts.escrow;
    //     let signer_key = ctx.accounts.client.key();

    //     require!(
    //         escrow.service_provider != Pubkey::default(),
    //         EscrowError::UninitializedEscrow
    //     );

    //     require!(signer_key == escrow.client, EscrowError::UnauthorizedSigner);

    //     escrow.client_approved = true;

    //     Ok(())
    // }

    // // Release the funds to the service provider
    // pub fn release_fund(ctx: Context<ReleaseFund>) -> Result<()> {
    //     let escrow = &mut ctx.accounts.escrow;
    //     let service_provider = ctx.accounts.service_provider.key();

    //     require!(
    //         escrow.service_provider != Pubkey::default(),
    //         EscrowError::UninitializedEscrow
    //     );
    //     require!(
    //         service_provider == escrow.service_provider,
    //         EscrowError::UnauthorizedSigner
    //     );
    //     require!(escrow.client_approved, EscrowError::NotApprovedForRealease);
    //     require!(!escrow.is_completed, EscrowError::EscrowAlreadyCompleted);

    //     escrow.is_completed = true;

    //     // Transfer the escrow amount to the service provider
    //     invoke_signed(
    //         &system_instruction::transfer(
    //             &escrow.key(),            // Escrow account (PDA)
    //             &escrow.service_provider, // Service provider's account
    //             escrow.amount,            // Amount to transfer
    //         ),
    //         &[
    //             escrow.to_account_info(), // Escrow account (must be writable)
    //             ctx.accounts.service_provider.to_account_info(),
    //             ctx.accounts.system_program.to_account_info(),
    //         ],
    //         &[&[
    //             b"escrow",                 // Seed for PDA
    //             &escrow.client.to_bytes(), // Client public key as part of the seed
    //             &[escrow.bump],            // Bump seed for the PDA
    //         ]],
    //     )?;

    //     Ok(())
    // }

}

// Account structures
#[derive(Accounts)]
pub struct InitializeEscrow<'info> {
    #[account(
        init,
        payer = client,
        space = 8 + 32 + 32 + 8 + 1 + 1, 
        // seeds = [b"escrow", client.key().as_ref()],
        // bump
    )]
    pub escrow: Account<'info, EscrowAccount>,
    
    #[account(mut)]
    pub client: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct AcceptService<'info> {
    #[account(mut)]
    pub escrow: Account<'info, EscrowAccount>,
    pub service_provider: Signer<'info>,
}

#[derive(Accounts)]
pub struct ApproveCompletion<'info> {
    #[account(mut)]
    pub escrow: Account<'info, EscrowAccount>,
    pub client: Signer<'info>,
}

#[derive(Accounts)]
pub struct ReleaseFund<'info> {
    #[account(mut)]
    pub escrow: Account<'info, EscrowAccount>,
    #[account(mut)] // Service provider must be writable to receive funds
    pub service_provider: Signer<'info>,
    pub system_program: Program<'info, System>,
}

// Escrow account data structure
#[account]
pub struct EscrowAccount {
    pub client: Pubkey,
    pub service_provider: Pubkey,
    pub amount: u64,
    pub client_approved: bool,
    pub is_completed: bool,
    pub bump: u8,
}

#[error_code]
pub enum EscrowError {
    #[msg("Service has already been accepted by another provider")]
    ServiceAlreadyAccepted,
    #[msg("Unauthorized signer for this operation")]
    UnauthorizedSigner,
    #[msg("Escrow account has not been initialized correctly")]
    UninitializedEscrow,
    #[msg("Insufficient balance in client account to initialize escrow")]
    InsufficientBalance,
    #[msg("Amount must be greater than zero")]
    InvalidAmount,
    #[msg("Client must approve Completion to withdraw funds")]
    NotApprovedForRealease,
    #[msg("Escrow already completed")]
    EscrowAlreadyCompleted,
}

// Events to track important actions
#[event]
pub struct EscrowInitialized {
    pub escrow: Pubkey,
    pub client: Pubkey,
    pub amount: u64,
}

#[event]
pub struct EscrowCompleted {
    pub escrow: Pubkey,
    pub service_provider: Pubkey,
    pub amount: u64,
}
